[{"title":"《JAVA-ACE-架构师系列视频课程- RocketMQ（上）》Study Notes","url":"/2023/%E3%80%8AJAVA-ACE-%E6%9E%B6%E6%9E%84%E5%B8%88%E7%B3%BB%E5%88%97%E8%A7%86%E9%A2%91%E8%AF%BE%E7%A8%8B-RocketMQ%EF%BC%88%E4%B8%8A%EF%BC%89%E3%80%8BStudy-Notes/","content":"\n\nRocketMQ简介简介\nRocketMQ是一款开源的、分布式、队列模型的消息中间件\n\n\n由阿里巴巴研发，借鉴参考了JMS规范的MQ实现，更参考了优秀的开源消息中间件Kafka，并且结合阿里实际业务需求，在天猫双十一的场景，实现业务消峰、分布式事务的优秀框架\n\n\nrocketmq github\n\n\n其底层代码编写清晰优秀，采用Netty NIO框架进行数据通信。\n\n\n3.X版本摒弃了ZooKeeper，内部使用更轻量级的NameServer进行网络路由，提高服务性能，并且支持消息失败重试机制**\n\n天然支持集群模型，消费者负载均衡、水平扩展能力，支持广播模式\n\n采用零拷贝的原理、顺序写盘、支持亿级消息堆积能力\n\n提供丰富的消息机制，如顺序消息、事务消息等\n\n\n\n\n\n\n特点 &amp; 优势\n能够保证严格的消息顺序\n提供丰富的消息拉取模式\n高效的订阅者水平扩展能力\n实时的消息订阅机制\n亿级消息堆积能力\nMetaq2.x版本之后：改名为RocketMQ\nRocket4.x ( 分布式事务。事务消息 )\n\n\n\n\n\n选择RocketMQ的理由\n强调集群无单点，可扩展，任意一点高可用，水平可扩展\n海量消息堆积能力，消息堆积后，写入低延迟\n支持上万个队列\n消息失败重试机制\n消息可查询\n开源社区活跃\n成熟度(经过双十一考验)\n\n\n\n\n\n核心概念&#x2F;专业术语\nProducer：消息生产者，负责产生消息，一般由业务系统负责产生消息\nConsumer：消息消费者，负责消费消息，一般是后台系统负责异步消费\nPush Consumer：Consumer 的一种，应用通常向 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立刻回调 Listener 接口方法\nPull Consumer：Consumer 的一种，应用通常主动调用 Consumer 的拉消息方法从 Broker 拉消息，主动权由应用控制。\nProducer Group：一类 Producer 的集合名称，返类 Producer 通常収送一类消息，丏収送逡辑一致\nConsumer Group：一类 Consumer 的集合名称，返类 Consumer 通常消费一类消息，且消费逻辑一致\nBroker：消息中转角色，负责存储消息，转发消息，一般也称为 Server。在 JMS 规范中称为 Provider\n广播消费：\n一条消息被多个 Consumer 消费，即使这些 Consumer 属于同一个 Consumer Group，消息也会被 Consumer Group 中的每个 Consumer 都消费一次，广播消费中的 Consumer Group 概念可以认为在消息划分方面无意义。\n在 CORBA Notification 规范中，消费方式都属亍广播消费。\n在 JMS 规范中，相当亍 JMS publish&#x2F;subscribe model\n\n\n集群消费：\n一个 Consumer Group 中的 Consumer 实例平均分摊消费消息。例如某个 Topic 有 9 条消息，其中一个Consumer Group 有 3 个实例（可能是 3 个迕程，或者 3 台机器），那举每个实例只消费其中的 3 条消息。\n在 CORBA Notification 规范中，无此消费方式。\n\n\n顺序消息：\n消费消息的顺序要同发送消息的顺序一致，在 RocketMQ 中，主要指的是局部顺序，即一类消息为满足顺序性，必须 Producer 单线程顺序发送，且发送到同一个队列，这样 Consumer 就可以按照 Producer 发送的顺序去消费消息\n\n\n普通顺序消息：\n顺序消息的一种，正常情况下可以保证完全的顺序消息，但是一旦发生通信异常，Broker 重启，由队列总数发生变化，哈希取模后定位的队列会变化，产生短暂的消息顺序不一致。\n如果业务能容忍在集群异常情况（如某个 Broker 宕机或者重启）下，消息短暂的乱序，使用普通顺序方式比较合适。\n\n\n严格顺序消息：\n顺序消息的一种，无论正常异常情况都能保证顺序，但是牺牲了分布式 Failover 特性，即 Broker 集群中只要有一台机器不可用，则整个集群都不可用，服务可用性大大降低。\n如果服务器部署为同步双写模式，此缺陷可通过备机自动切换为主避免，不过仍然会存在几分钟的服务不可用。（依赖同步双写，主备自动切换，自动切换功能目前还未实现）\n目前已知的应用只有数据库 binlog 同步强依赖严格顺序消息，其他应用绝大部分都可以容忍短暂乱序，推荐使用普通的顺序消息。\n\n\nMessage Queue：\n在 RocketMQ 中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用 Offset 来访问，offset 为 java long 类型，64 位，理论上在 100年内不会溢出，所以认为是长度无限，另外队列中只保存最近几天的数据，之前的数据会按照过期时间来删除。\n也可以认为 Message Queue 是一个长度无限的数组，offset 就是下标。\n\n\n\n\n\n\n\nRocketMQ OverviewRocketMQ 是什么？\n是一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式特点。\nProducer、Consumer、队列都可以分布式。\nProducer 吐一些队列轮流収送消息，队列集合称为 Topic，Consumer 如果做广播消费，则一个 consumer实例消费返个 Topic 对应的所有队列，如果做集群消费，则多个 Consumer 实例平均消费返个 topic 对应的队列集合。\n能够保证严格的消息顺序\n提供丰富的消息拉取模式\n高效的订阅者水平扩展能力\n实时的消息订阅机制\n亿级消息堆积能力\n较少的依赖\n\n\n\nRocketMQ 物理部署结构\nRocketMQ 网络部署图\n\n\n\n\nName Server 是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。\nBroker 部署相对复杂，Broker 分为 Master 与 Slave，一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个Master，Master与 Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定指定，BrokerId为 0 表示 Master，非 0 表示 Slave。Master 也可以部署多个。每个 Broker 与 Name Server 集群中的所有节点建立长连接，定时注册 Topic 信息到所有 Name Server。\nProducer 与 Name Server 集群中的其中一个节点（随机选择）建立长连接，定期从 Name Server 取 Topic 路 由信息，并向提供 Topic 服务的 Master 建立长连接，且定时向 Master 发送心跳。Producer 完全无状态，可 集群部署。\nConsumer 与Name Server 集群中的其中一个节点（随机选择）建立长连接，定期从 Name Server 取 Topic 路 由信息，并向提供 Topic 服务的 Master、Slave 建立长连接，且定时向 Master、Slave 发送心跳。Consumer 既可以从 Master 订阅消息，也可以从 Slave 订阅消息，订阅规则由 Broker 配置决定。\n\n\n\nRocketMQ 逻辑部署结构\nRocketMQ 逻辑部署结构图\n\n\n\n\nProducer Group\n用来表示一个发送消息应用，一个 Producer Group 下包含多个 Producer 实例，可以是多台机器，也可以 是一台机器的多个进程，或者一个进程的多个 Producer 对象。一个 Producer Group 可以发送多个 Topic 消息，Producer Group 作用如下：\n标识一类 Producer \n可以通过运维工具查询返个収送消息应用下有多个 Producer 实例 \n収送分布式事务消息时，如果 Producer 中途意外宕机，Broker 会主劢回调 Producer Group 内的任意 一台机器来确认事务状态。\n\n\n\n\nConsumer Group \n用来表示一个消费消息应用，一个 Consumer Group 下包含多个 Consumer 实例，可以是多台机器，也可 以是多个迕程，或者是一个进程的多个 Consumer 对象。一个 Consumer Group 下的多个 Consumer 以均摊 方式消费消息，如果设置为广播方式，那么这个 Consumer Group 下的每个实例都消费全量数据。\n\n\n\n\n\n\n\n\n\n集群环境集群环境介绍\nRocketMQ就是为了分布式而产生的，当然天然支持集群\nRocketMO的集群模型：\n单机模式(M)\n方式风险较大，一旦 Broker 重启戒者宕机时，会导致整个服务丌可用，丌建议线上环境使用\n\n\nMaster-Slave模式(M-S)\n双（多）Master模式 ( 2M)\n优点：配置简单，单个 Master 宕机戒重启维护对应用无影响消息也丌会丢（异步刷盘丢失少量消息，同步刷盘一条丌丢）。性能最高\n缺点：单台机器宕机期间，返台机器上未被消费的消息在机器恢复乀前丌可订阅，消息实时性会叐到叐到影响\n\n\n双主双从模式(2M-2S)\n多主多从模式(NM-NS)\n多 Master 多 Slave 模式，异步复制\n优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响\n缺点：Master 宕机，磁盘损坏情冴，会丢失少量消息\n\n\n多 Master 多 Slave 模式，同步双写\n优点：数据不服务都无单点，Master 宕机情冴下，消息无延迟，服务可用性不数据可用性都非常高\n缺点：性能比异步复制模式略低，大约低 10%左史，収送单个消息的 RT 会略高。目前主宕机后，备机丌能自动切换为主机，后续会支持自劢切换功能。\n\n\n\n\n\n\n\n\n\n\n\nRocketMQ 部署【双Master 方式】服务器环境\n\n\n序号\nIP\n用户名\n角色\n模式\n\n\n\n1\n192.168.137.201\nroot\nnameServer1,brokerServer1\nMaster1\n\n\n2\n192.168.137.202\nroot\nnameServer2,brokerServer2\nMaster2\n\n\n\n\nHosts 添加信息【两台机器】\n注意：两台机器需要在9876端口互通，需要开通相关网络策略\n\nvim /etc/hosts\n\n192.168.137.201  rocketmq-nameserver1192.168.137.201  rocketmq-master1192.168.137.202  rocketmq-nameserver2192.168.137.202  rocketmq-master2\n\n\n\n上传安装包并解压【两台机器】#  上传 alibaba-rocketmq-3.2.6.tar.gz 文件至/usr/local/src/tar -zxvf /usr/local/src/alibaba-rocketmq-3.2.6.tar.gz -C /usr/local/mv /usr/local/alibaba-rocketmq /usr/local/alibaba-rocketmq-3.2.6ln -s /usr/local/alibaba-rocketmq-3.2.6 /usr/local/rocketmq\n\n\n\n创建存储路径【两台机器】mkdir /usr/local/rocketmq/storemkdir /usr/local/rocketmq/store/commitlogmkdir /usr/local/rocketmq/store/consumequeuemkdir /usr/local/rocketmq/store/index\n\n\n\n修改RocketMQ  配置文件【两台机器】vim /usr/local/rocketmq/conf/2m-noslave/broker-a.properties\n\nbrokerClusterName=rocketmq-cluster#broker 名字，注意此处不同的配置文件填写的不一样brokerName=broker-a#0 表示 Master，&gt;0 表示 SlavebrokerId=0#nameServer 地址，分号分割namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876#在发送消息时，自动创建服务器不存在的 topic，默认创建的队列数defaultTopicQueueNums=4#是否允许 Broker 自动创建 Topic，建议线下开启，线上关闭autoCreateTopicEnable=true#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup=true#Broker 对外服务的监听端口listenPort=10911#删除文件时间点，默认凌晨 4 点deleteWhen=04#文件保留时间，默认 48 小时fileReservedTime=120#commitLog 每个文件的大小默认 1GmapedFileSizeCommitLog=1073741824#ConsumeQueue 每个文件默认存 30W 条，根据业务情况调整mapedFileSizeConsumeQueue=300000#destroyMapedFileIntervalForcibly=120000#redeleteHangedFileInterval=120000#检测物理文件磁盘空间diskMaxUsedSpaceRatio=88#存储路径storePathRootDir=/usr/local/rocketmq/store#commitLog 存储路径storePathCommitLog=/usr/local/rocketmq/store/commitlog#消费队列存储路径存储路径storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue#消息索引存储路径storePathIndex=/usr/local/rocketmq/store/index#checkpoint 文件存储路径storeCheckpoint=/usr/local/rocketmq/store/checkpoint#abort 文件存储路径abortFile=/usr/local/rocketmq/store/abort#限制的消息大小maxMessageSize=65536#flushCommitLogLeastPages=4#flushConsumeQueueLeastPages=2#flushCommitLogThoroughInterval=10000#flushConsumeQueueThoroughInterval=60000#Broker 的角色#- ASYNC_MASTER 异步复制 Master#- SYNC_MASTER 同步双写 Master#- SLAVEbrokerRole=ASYNC_MASTER#刷盘方式#- ASYNC_FLUSH 异步刷盘#- SYNC_FLUSH 同步刷盘flushDiskType=ASYNC_FLUSH#checkTransactionMessageEnable=false#发消息线程池数量#sendMessageThreadPoolNums=128#拉消息线程池数量#pullMessageThreadPoolNums=128\n\nvim /usr/local/rocketmq/conf/2m-noslave/broker-b.properties\n\nbrokerClusterName=rocketmq-cluster#broker 名字，注意此处不同的配置文件填写的不一样brokerName=broker-b#0 表示 Master，&gt;0 表示 SlavebrokerId=0#nameServer 地址，分号分割namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876#在发送消息时，自动创建服务器不存在的 topic，默认创建的队列数defaultTopicQueueNums=4#是否允许 Broker 自动创建 Topic，建议线下开启，线上关闭autoCreateTopicEnable=true#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup=true#Broker 对外服务的监听端口listenPort=10911#删除文件时间点，默认凌晨 4 点deleteWhen=04#文件保留时间，默认 48 小时fileReservedTime=120#commitLog 每个文件的大小默认 1GmapedFileSizeCommitLog=1073741824#ConsumeQueue 每个文件默认存 30W 条，根据业务情况调整mapedFileSizeConsumeQueue=300000#destroyMapedFileIntervalForcibly=120000#redeleteHangedFileInterval=120000#检测物理文件磁盘空间diskMaxUsedSpaceRatio=88#存储路径storePathRootDir=/usr/local/rocketmq/store#commitLog 存储路径storePathCommitLog=/usr/local/rocketmq/store/commitlog#消费队列存储路径存储路径storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue#消息索引存储路径storePathIndex=/usr/local/rocketmq/store/index#checkpoint 文件存储路径storeCheckpoint=/usr/local/rocketmq/store/checkpoint#abort 文件存储路径abortFile=/usr/local/rocketmq/store/abort#限制的消息大小maxMessageSize=65536#flushCommitLogLeastPages=4#flushConsumeQueueLeastPages=2#flushCommitLogThoroughInterval=10000#flushConsumeQueueThoroughInterval=60000#Broker 的角色#- ASYNC_MASTER 异步复制 Master#- SYNC_MASTER 同步双写 Master#- SLAVEbrokerRole=ASYNC_MASTER#刷盘方式#- ASYNC_FLUSH 异步刷盘#- SYNC_FLUSH 同步刷盘flushDiskType=ASYNC_FLUSH#checkTransactionMessageEnable=false#发消息线程池数量#sendMessageThreadPoolNums=128#拉消息线程池数量#pullMessageThreadPoolNums=128\n\n\n\n修改日志配置文件【两台机器】mkdir -p /usr/local/rocketmq/logscd /usr/local/rocketmq/conf &amp;&amp; sed -i &#x27;s#$&#123;user.home&#125;#/usr/local/rocketmq#g&#x27; *.xml\n\n\n\n修改启动脚本参数【两台机器】vim /usr/local/rocketmq/bin/runbroker.sh\n\n#==============================================================================# 开发环境 JVM Configuration#==============================================================================JAVA_OPT=&quot;$&#123;JAVA_OPT&#125;  -server  -Xms1g  -Xmx1g  -Xmn512m  -XX:PermSize=128m  -XX:MaxPermSize=320m&quot;\n\nvim /usr/local/rocketmq/bin/runserver.sh\n\nJAVA_OPT=&quot;$&#123;JAVA_OPT&#125;  -server  -Xms1g  -Xmx1g  -Xmn512m  -XX:PermSize=128m  -XX:MaxPermSize=320m&quot;\n\n\n\n启动 NameServer 【两台机器】cd /usr/local/rocketmq/binnohup sh mqnamesrv &amp;jps\n\n\n\n启动 BrokerServer1cd /usr/local/rocketmq/binnohup sh mqbroker -c /usr/local/rocketmq/conf/2m-noslave/broker-a.properties &gt;/dev/null 2&gt;&amp;1 &amp;netstat -ntlpjpstail -f -n 500 /usr/local/rocketmq/logs/rocketmqlogs/broker.logtail -f -n 500 /usr/local/rocketmq/logs/rocketmqlogs/namesrv.log\n\n\n\n启动 BrokerServer2cd /usr/local/rocketmq/binnohup sh mqbroker -c /usr/local/rocketmq/conf/2m-noslave/broker-b.properties &gt;/dev/null 2&gt;&amp;1 &amp;netstat -ntlpjpstail -f -n 500 /usr/local/rocketmq/logs/rocketmqlogs/broker.logtail -f -n 500 /usr/local/rocketmq/logs/rocketmqlogs/namesrv.log\n\n\n\n\n\nRocketMQ 监控台\n我们使用RocketMQ自带的web项目监控集群消费信息。rocketmg-console-3.26war把这个部署到tomcat上即可\n\ncd /usr/local/src/# 上传 apache-tomcat-8.5.93.tar.gz 到 /usr/local/src/ 目录下tar -zxvf  apache-tomcat-8.5.93.tar.gz -C /usr/local/# 上传 rocketmq-console.war 到 /usr/local/apache-tomcat-8.5.93/webapps/ 目录下cd /usr/local/apache-tomcat-8.5.93/webapps/unzip rocketmq-console.war -d rocketmq-consolerm -rf rocketmq-console.war\n\nvim /usr/local/apache-tomcat-8.5.93/webapps/rocketmq-console/WEB-INF/classes/config.properties\n\nrocketmq.namesrv.addr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876throwDone=true\n\n/usr/local/apache-tomcat-8.5.93/bin/startup.sh\n\n\nhttp://192.168.137.201:8080/rocketmq-console/\n\n\n\n\n\n\n\nBroker配置文件详解brokerClusterName=rocketmq-cluster#broker 名字，注意此处不同的配置文件填写的不一样brokerName=broker-a#0 表示 Master，&gt;0 表示 SlavebrokerId=0#nameServer 地址，分号分割namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876#在发送消息时，自动创建服务器不存在的 topic，默认创建的队列数defaultTopicQueueNums=4#是否允许 Broker 自动创建 Topic，建议线下开启，线上关闭autoCreateTopicEnable=true#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup=true#Broker 对外服务的监听端口listenPort=10911#删除文件时间点，默认凌晨 4 点deleteWhen=04#文件保留时间，默认 48 小时fileReservedTime=120#commitLog 每个文件的大小默认 1GmapedFileSizeCommitLog=1073741824#ConsumeQueue 每个文件默认存 30W 条，根据业务情况调整mapedFileSizeConsumeQueue=300000#destroyMapedFileIntervalForcibly=120000#redeleteHangedFileInterval=120000#检测物理文件磁盘空间diskMaxUsedSpaceRatio=88#存储路径storePathRootDir=/usr/local/rocketmq/store#commitLog 存储路径storePathCommitLog=/usr/local/rocketmq/store/commitlog#消费队列存储路径存储路径storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue#消息索引存储路径storePathIndex=/usr/local/rocketmq/store/index#checkpoint 文件存储路径storeCheckpoint=/usr/local/rocketmq/store/checkpoint#abort 文件存储路径abortFile=/usr/local/rocketmq/store/abort#限制的消息大小maxMessageSize=65536#flushCommitLogLeastPages=4#flushConsumeQueueLeastPages=2#flushCommitLogThoroughInterval=10000#flushConsumeQueueThoroughInterval=60000#Broker 的角色#- ASYNC_MASTER 异步复制 Master#- SYNC_MASTER 同步双写 Master#- SLAVEbrokerRole=ASYNC_MASTER#刷盘方式#- ASYNC_FLUSH 异步刷盘#- SYNC_FLUSH 同步刷盘flushDiskType=ASYNC_FLUSH#checkTransactionMessageEnable=false#发消息线程池数量#sendMessageThreadPoolNums=128#拉消息线程池数量#pullMessageThreadPoolNums=128\n\n\n\n\n\n\n\nRocketMQ hello word 模型生产者\n第一步:创建DefaultMOProducer类并设定生产者名称，设置setNamesrvAddr，集群模式用”;”进行分割，调用start方法启动即可\n第二步:使用Message类进行实例化消息，参数分别为:主题、标签、内容\n第三步:调用send方法发送消息，并且关闭生产者即可\n\npublic class Producer &#123;\t\tpublic static void main(String[] args) throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;\t\t//第一步:创建DefaultMOProducer类并设定生产者名称，设置setNamesrvAddr，集群模式用&quot;;&quot;进行分割，调用start方法启动即可\t\tDefaultMQProducer producer = new DefaultMQProducer(&quot;quickstart_producer&quot;);\t\t\t\tproducer.setNamesrvAddr(&quot;192.168.137.201:9876;192.168.137.202:9876&quot;);\t\tproducer.start();\t\t\t\tfor (int i = 0;i&lt;10;i++) &#123;\t\t\t// 第二步:使用Message类进行实例化消息，参数分别为:主题、标签、内容\t\t\tMessage message = new Message(&quot;TopicQuickStart&quot;,&quot;tagA&quot;,&quot;key1&quot;,(&quot;this is a message&quot;+i).getBytes());\t\t\t// 第三步:调用send方法发送消息，并且关闭生产者即可\t\t\tSendResult sendResult = producer.send(message);\t\t\tSystem.out.println(sendResult);\t\t&#125;\t\tproducer.shutdown();\t&#125;&#125;\n\n\n\n\n\n消费者\n第一步:创建DefaultMOPushConsumer类并设定消费者名称，设置setNamesrvAddr，集群模式用”;”进行分割\n第二步:设置DefauitMQPushConsumer实例的订阅主题，一个消费者对荣可以订阅多个主题，使用subscribe方法订园(参数1王题名称，参数2标签内容，可以使用” ”对标签内容进行合并获取)\n第三步:消费者实例进行注册监听:设置registerMessageListener方法。\n第四步:监听类实现MessagelistenerConcurrently接口即可，重写consumeMessage方法接受数据\nConsumeConcurrentlyStatusRECONSUME LATER\nConsumeConcurrentlyStatus.CONSUMESUCCESS\n\n\n第五步:启动消费者实例对象，调用start方法即可\n\npublic class Consumer &#123;\t\tpublic static void main(String[] args) throws MQClientException &#123;\t\t// 第一步:创建DefaultMOPushConsumer类并设定消费者名称，设置setNamesrvAddr，集群模式用&quot;;&quot;进行分割\t\tDefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;quickstart_consumer&quot;);\t\tconsumer.setNamesrvAddr(&quot;192.168.137.201:9876;192.168.137.202:9876&quot;);\t\t\t\t//- 第二步:设置DefauitMQPushConsumer实例的订阅主题，一个消费者对荣可以订阅多个主题，使用subscribe方法订园(参数1王题名称，参数2标签内容，可以使用&quot; ”对标签内容进行合并获取)\t\tconsumer.subscribe(&quot;TopicQuickStart&quot;, &quot;*&quot;);\t\tconsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\t\t//- 第三步:消费者实例进行注册监听:设置registerMessageListener方法。\t\t//- 第四步:监听类实现MessagelistenerConcurrently接口即可，重写consumeMessage方法接受数据\t\tconsumer.registerMessageListener(new MessageListenerConcurrently() &#123;\t\t\t\t\t\t@Override\t\t\tpublic ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext arg1) &#123;\t\t\t\ttry &#123;\t\t\t\t\tSystem.out.println(&quot;条数：&quot;+msgs.size());\t\t\t\t\t\t\t\t\t\tMessageExt messageExt = msgs.get(0);\t\t\t\t\tString topic = messageExt.getTopic();\t\t\t\t\tString tags = messageExt.getTags();\t\t\t\t\tString body  = new String(messageExt.getBody(),&quot;utf-8&quot;);\t\t\t\t\tSystem.out.println(&quot;topic:&quot;+topic);\t\t\t\t\tSystem.out.println(&quot;tags:&quot;+tags);\t\t\t\t\tSystem.out.println(&quot;body:&quot;+body);\t\t\t\t&#125;catch (Exception e) &#123;\t\t\t\t\te.printStackTrace();\t\t\t\t\treturn ConsumeConcurrentlyStatus.RECONSUME_LATER;\t\t\t\t&#125;\t\t\t\treturn ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\t\t\t&#125;\t\t&#125;);\t\t\t\t// 第五步:启动消费者实例对象，调用start方法即可\t\tconsumer.start();\t\tSystem.out.println(&quot;Consumer start...&quot;);\t&#125;&#125;\n\n\n\n\n\n\n\nRocketMQ Java API helloword\n\n\n\n\n\n\n\n\n\n标题二\n\n\n\n\n\nReference\nJAVA-ACE-架构师系列视频课程- RocketMQ（上）\n\n\n\n\n\n\n\nRemark\n\n熟悉一下RocketMQ的官网，看看相关文档\nhello word部分实践过一遍，以后还应该再学习一下\n不同集群环境的优缺点这块需要补充笔记（3），需要熟悉\n\n\n&lt;font color=red&gt;&lt;/font&gt;![]()&lt;img src=&quot;&quot; title=&quot;图片名称&quot; alt=&quot;图片无法正常加载展示！&quot; width=&quot;100%&quot; height=&quot;100%&quot; &gt;&lt;img src=&quot;&quot; width=&quot;90%&quot;&gt;&lt;img src=&quot;&quot; width=&quot;70%&quot;&gt;****\n\n\n\n\n","categories":["MQ","RocketMQ"],"tags":["MQ","RocketMQ"]}]