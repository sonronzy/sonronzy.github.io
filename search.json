[{"title":"《Java设计模式精讲 Debug方式+内存分析》Study Notes","url":"/2024/%E3%80%8AJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B2%BE%E8%AE%B2-Debug%E6%96%B9%E5%BC%8F-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E3%80%8BStudy-Notes/","content":"\n\n慕课网课程《Java设计模式精讲 Debug方式+内存分析》的学习笔记。\n\n\n第1章 课程导学\n设计模式是工程师必备的知识，也是面试高频考点\n\n本课程讲解设计模式的方式：\n\n设计模式定义\n设计模式应用\n源码解析\n系统学习设计模式\n结合大量场景coding（不枯燥、不空洞）\n动态递进式讲解（场景-UML-代码）\n采用Debug方式及内存分析（更容易理解设计模式）\nJDK及热门开源框架源码解析\n\n\nUML入门\n\nUML基础\nUML类图\nUML时序图\nUML类关系\nUML记忆技巧\n\n\n7大设计原则\n\n开闭原则\n依赖倒置原则\n单一职责原则\n接口隔离原则\n迪米特原则\n里氏替换原则\n合成复用原则\n\n\n设计模式\n\n创建型模式\n\n工厂模式（Factory Pattern）\n抽象工厂模式（Abstract Factory Pattern）\n单例模式（Singleton Pattern）\n建造者模式（Builder Pattern）\n原型模式（Prototype Pattern）\n\n\n结构型模式\n\n适配器模式（Adapter Pattern）\n桥接模式（Bridge Pattern）\n过滤器模式（Filter、Criteria Pattern）\n组合模式（Composite Pattern）\n装饰器模式（Decorator Pattern）\n外观模式（Facade Pattern）\n享元模式（Flyweight Pattern）\n代理模式（Proxy Pattern）\n\n\n行为型模式\n\n责任链模式（Chain of Responsibility Pattern）\n命令模式（Command Pattern）\n解释器模式（Interpreter Pattern）\n迭代器模式（Iterator Pattern）\n中介者模式（Mediator Pattern）\n备忘录模式（Memento Pattern）\n观察者模式（Observer Pattern）\n状态模式（State Pattern）\n空对象模式（Null Object Pattern）\n策略模式（Strategy Pattern）\n模板模式（Template Pattern）\n访问者模式（Visitor Pattern）\n\n\n\n\n\n\n\n\n\n\n\n第2章 UML急速入门\n\n\n\n\n\n第3章 软件设计七大原则\n\n\n\n\n\n第4章 简单工厂\n定义：由一个工厂对象决定创建出哪一种产品类的实例\n类型：创建型（但不属于GOF23种设计模式）\n适用场景：\n工厂类负责创建的对象比较少\n客户端（应用层）只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心\n\n\n优点：\n只需要传入一个参数就可以获取所需的对象，而无需知道其创建细节\n\n\n缺点：\n工厂类的职责过重，当增加新的产品时候需要修改工厂类的判断逻辑，违背开闭原则\n\n\n源码中简单工厂的使用：\njdk源码 Calendar.java\n\n\n\n\n\n\n\n\n\n标题二\n\n\n\n\n\nReference\n\n\n\n\n\n\n\n\nRemark\n\nxxx需要再深入学习\n\n\n&lt;font color=red&gt;&lt;/font&gt;![]()&lt;img src=&quot;&quot; title=&quot;图片名称&quot; alt=&quot;图片无法正常加载展示！&quot; width=&quot;100%&quot; height=&quot;100%&quot; &gt;&lt;img src=&quot;&quot; width=&quot;70%&quot;&gt;****\n\n\n\n\n","categories":["design-pattern"],"tags":["design-pattern"]},{"title":"《搞定数据库事务 含seata分布式》Study Notes","url":"/2024/%E3%80%8A%E6%90%9E%E5%AE%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1-%E5%90%ABseata%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%8BStudy-Notes/","content":"\n\nbasic conceptWhat’s Transaction\n定义： 数据库事务是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)\n组成： 一个数据库事务通常包含对数据库进行读或写的一个操作序列\n目的：\n（1）为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法\n（2）当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰\n\n\n\n\n\n\n\n事务目标（目的）分析\n事务的目的就是要提供3种方法：\n\n（1）失败恢复方法\n（2）保持一致性的方法\n（3）操作隔离的方法\n\n\n成功情况下：能将数据从一种状态变为另外一种状态，并能够持久化\n\n异常情况下：\n\n能将数据恢复到正常状态\n要能保证一致性，包含数据的一致性和约束的一致性\n\n\n并发情况下：并发的操作之间不能产生相互影响\n\n\n\n\n\n\nTransaction Features\n事务的目的指向了事务的特性\n\n\n原子性Actomicity：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行\n一致性 Consistency：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束\n隔离性 Isolation：多个事务并发执行时，一个事务的执行不应影响其他事务的执行\n持久性 Durability：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中\n\n\n\n\n\nTransaction Concurrency Exception\nUpdate Lost&#x2F;回滚丢失&#x2F;第一类更新丢失：此种更新丢失是因为回滚的原因，所以也叫回滚丢失\nSeconde Update Lost&#x2F;覆盖丢失&#x2F;第二类更新丢失：此种更新丢失是因为更新被其他事务给覆盖了，也可以叫覆盖丢失\nDirty Read&#x2F;脏读：此种异常时因为一个事务读取了另一个事务修改了但是未提交的数据\nNot Repeatable Read&#x2F;不可重复读：一个事务对同一行数据执行了两次或更多次查询，但是却得到了不同的结果\nPhantom Read&#x2F;幻读：幻读和不可重复读有点像，只是针对的不是数据的值而是数据的数量\n\nUpdate Lost&#x2F;回滚丢失\n\n\n事务A\n事务B\n\n\n\n查询数据得到初始值10\n查询数据得到初始值10\n\n\n更新为10+1&#x3D;11\n更新10+2&#x3D;12\n\n\n提交\n失败回滚\n\n\n\n数据回到初始化状态10，导致事务A的更新丢失了由于回滚导致丢失所以叫做回滚丢失\n\n\nSeconde Update Lost&#x2F;覆盖丢失\n\n\n事务A\n事务B\n\n\n\n查询数据得到初始值10\n查询数据得到初始值10\n\n\n更新为10+1&#x3D;11\n更新10+2&#x3D;12\n\n\n提交\n提交\n\n\n\n最终结果变为12由于事务B是从10开始计算，并不知道数据已经发生了变化，所以导致事务A的更新结果被覆盖了，所以叫覆盖更新。\n\n\nDirty Read\n\n\n事务A\n事务B\n\n\n\n查询数据得到初始值10\n查询数据得到初始值10\n\n\n更新为10+1&#x3D;11\n再此读取数值的到11\n\n\n\n更新数据11+1&#x3D;12\n\n\n回滚\n提交\n\n\n\n最终数据变为12由于读取到的数据11被回滚了，结果是错误的，读取到了脏数据\n\n\nNot Repeatable Read\n\n\n事务A\n事务B\n\n\n\n查询数据得到初始值10\n查询数据得到初始值10\n\n\n\n再此读取数据得到11\n\n\n\n在一个事务内两次对同一条数据查询，得到的结果是不同的，因此叫做不可重复读\n\n\nPhantom Read\n\n\n事务A\n事务B\n\n\n\n查询数据有11条\n查询数据有是一条\n\n\n更新全部数据为1\n插入一条数据\n\n\n查询结果由一条没被更新，比原来多了一条\n\n\n\n仿佛全表更新语句不正常，自己出现了幻觉，因此叫幻读\n\n\n\n\n\n\n\nTransaction Isolation LevelRead Uncommitted\n即使一个事务的更新语句没有提交，但是别的事务可以读到这个改变\n无法消除任何事务并发异常\n\nRead Committed\n一个事务只能看到其他事务的已经提交的更新，看不到未提交的更新\n消除了脏读和第一类丢失更新\n这是大多数数据库的默认隔离级别：Oracle、SqlServer\n\nRepeatable Read\n一个事务中进行两次或多次同样的对于数据内容的查询，得到的结果是一样的，但不保证对于数据条数的查询是一样的，只要存在读改行数据就禁止写\n消除了不可重复读和第二类更新丢失\n这是Mysql数据库的默认隔离级别\n\nSerializable\n事务执行的时候不允许别的事务并发执行，完全串行化的读，只要存在读就禁止写，但可以同时读\n消除了幻读\n这是事务隔离的最高级别，虽然最安全最省心，但是效率太低，一般不会用\n\n各种隔离级别能解决哪些并发异常\n\n\n隔离级别\\并发异常\n回滚丢失\n脏读\n不可重复读\n覆盖丢失\n幻读\n\n\n\n读未提交\n×\n×\n×\n×\n×\n\n\n读已提交\n✓\n✓\n×\n×\n×\n\n\n可重复读\n✓\n✓\n✓\n✓\n×\n\n\n串行化\n✓\n✓\n✓\n✓\n✓\n\n\n\n\n\n\n\n\nTransaction Isolation Operatorenvironment\n环境信息\n\n# 使用的数据库以及版本信息mysql&gt; select version();+-----------+| version() |+-----------+| 5.7.26    |+-----------+# MySQL InnoDB引擎的默认隔离级别为REPEATABLE-READ\n\n\n操作指令\n\n# 查看数据库版本：select version();# 查看隔离级别：select @@session.tx_isolation;# （会话级）修改隔离级别：set @@session.tx_isolation=&#x27;参数&#x27;;# 可选参数set @@session.tx_isolation=&#x27;READ-UNCOMMITTED&#x27;;set @@session.tx_isolation=&#x27;READ-COMMITTED&#x27;;set @@session.tx_isolation=&#x27;REPEATABLE-READ&#x27;;set @@session.tx_isolation=&#x27;SERIALIZABLE&#x27;;# 开启事务：start transaction;# 提交：commit;# 回滚rollback;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpring TransactionSpring事务注解\n\n\n参数名称\n功能描述\n\n\n\nreadOnly\n该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。例如：@Transactional(readOnly&#x3D;true)\n\n\nrollbackFor\n该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。例如：指定单一异常类：@Transactional(rollbackFor&#x3D;RuntimeException.class)指定多个异常类：@Transactional(rollbackFor&#x3D;{RuntimeException.class, Exception.class})\n\n\nrollbackForClassName\n该属性用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。例如：指定单一异常类名称@Transactional(rollbackForClassName&#x3D;”RuntimeException”)指定多个异常类名称：@Transactional(rollbackForClassName&#x3D;{“RuntimeException”,”Exception”})\n\n\nnoRollbackFor\n该属性用于设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚。例如：指定单一异常类：@Transactional(noRollbackFor&#x3D;RuntimeException.class)指定多个异常类：@Transactional(noRollbackFor&#x3D;{RuntimeException.class, Exception.class})\n\n\nnoRollbackForClassName\n该属性用于设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚。例如：指定单一异常类名称：@Transactional(noRollbackForClassName&#x3D;”RuntimeException”)指定多个异常类名称：@Transactional(noRollbackForClassName{“RuntimeException”,”Exception”})\n\n\npropagation\n该属性用于设置事务的传播行为。例如Transactional(propagation&#x3D;Propagation.NOT_SUPPORTED,readOnly&#x3D;true)\n\n\nisolation\n该属性用于设置底层数据库的事务隔离级别，事务隔离级别用于处理多事务并发的情况，通常使用数据库的默认隔离级别即可，基本不需要进行设置\n\n\ntimeout\n该属性用于设置事务的超时秒数，默认值为-1表示永不超时\n\n\n\n\n\n\nSpring事务传播行为\n\n\n传播行为\n含义\n\n\n\nREQUIRED\n表示当前方法必须在一个具有事务的上下文中运行，如有客户端有事务在进行，那么被调用端将在该事务中运行，否则的话重新开启一个事务。（如果被调用端发生异常，那么调用端和被调用端事务都将回滚）\n\n\nSUPPORTS\n表示当前方法不必需要具有一个事务上下文，但是如果有一个事务的话，它也可以在这个事务中运行\n\n\nMANDATORY\n表示当前方法必须在一个事务中运行，如果没有事务，将抛出异常\n\n\nNESTED\n表示如果当前方法正有一个事务在运行中，则该方法应该运行在一个嵌套事务中，被嵌套的事务可以独立于被封装的事务中进行提交或者回滚。如果封装事务存在，并且外层事务抛出异常回滚，那么内层事务必须回滚，反之，内层事务并不影响外层事务。如果封装事务不存在，则同PROPAGATION_REQUIRED的一样\n\n\nNEVER\n表示当方法务不应该在一个事务中运行，如果存在一个事务，则抛出异常\n\n\nREQUIRES_NEW\n表示当前方法必须运行在它自己的事务中。一个新的事务将启动，而且如果有一个现有的事务在运行的话，则这个方法将在运行期被挂起，直到新的事务提交或者回滚才恢复执行。\n\n\nNOT_SUPPORTED\n表示该方法不应该在一个事务中运行。如果有一个事务正在运行，他将在运行期被挂起，直到这个事务提交或者回滚才恢复执行\n\n\n\n\n\n\nSpring隔离级别\n\n\n隔离级别\n含义\n\n\n\nidefault\n使用数据库默认的事务隔离级别\n\n\nread_uncommitted\n允许读取尚未提交的修改，可能导致脏读、幻读和不可重复读\n\n\nread_committed\n允许从已经提交的事务读取，可防止脏读、但幻读，不可重复读仍然有可能发生\n\n\nrepeatable_read\n对相同字段的多次读取的结果是一致的，除非数据被当前事务自生修改。可防止脏读和不可重复读，但幻读仍有可能发生\n\n\nserializable\n完全服从acid隔离原则，确保不发生脏读、不可重复读、和幻读，但执行效率最低。\n\n\n\n\n\n\n\n\nDistributed Transactions\n\n\n\n\n\n标题3\n\n\n\n\n\nReference\n\n\n\n\n\n\n\n\nRemark\n\n事务并发异常和事务隔离级别非常非常重要需要熟记\n需要整理不同隔离级别的并发性能，需要理解并记忆不同隔离级别为何能消除某些事务并发异常\n\n\n&lt;font color=red&gt;&lt;/font&gt;![]()&lt;img src=&quot;&quot; title=&quot;图片名称&quot; alt=&quot;图片无法正常加载展示！&quot; width=&quot;100%&quot; height=&quot;100%&quot; &gt;&lt;img src=&quot;&quot; width=&quot;70%&quot;&gt;****\n\n\n\n\n","categories":["Distributed-Transaction","Transaction"],"tags":["Distributed-Transaction","Transaction"]},{"title":"《JAVA-ACE-架构师系列视频课程- RocketMQ（上）》Study Notes","url":"/2024/%E3%80%8AJAVA-ACE-%E6%9E%B6%E6%9E%84%E5%B8%88%E7%B3%BB%E5%88%97%E8%A7%86%E9%A2%91%E8%AF%BE%E7%A8%8B-RocketMQ%EF%BC%88%E4%B8%8A%EF%BC%89%E3%80%8BStudy-Notes/","content":"\n\n文章摘要信息……\n\n\n标题一\n\n\n\n\n\n标题二\n\n\n\n\n\nReference\n\n\n\n\n\n\n\n\nRemark\n\nxxx需要再深入学习\n\n\n&lt;font color=red&gt;&lt;/font&gt;![]()&lt;img src=&quot;&quot; title=&quot;图片名称&quot; alt=&quot;图片无法正常加载展示！&quot; width=&quot;100%&quot; height=&quot;100%&quot; &gt;&lt;img src=&quot;&quot; width=&quot;70%&quot;&gt;****\n\n\n\n\n"},{"title":"《程序员职业规划手册》Study Notes","url":"/2024/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92%E6%89%8B%E5%86%8C%E3%80%8BStudy-Notes/","content":"\n\n前言&emsp;&emsp;最近学习了极客时间上雪梅老师的专栏《程序员职业规划手册》，收获不小。整理了学习笔记，便于复习、消化。\n\n\n\n\n\n\n开篇词开篇词｜超越“内卷”，拿回你的职业主动权概述\n职业发展的焦虑与困惑\nAI 在发展，技术岗未来还有机会吗？\n35+ 技术人危机\n卷不动，躺不平，怎么破\n\n\n\n怎么理解（认知）职业发展？\n\n\n（1）职业发展没有确定的路径，是打“移动靶”\n\n市场一直在变化，企业需求会变，岗位要求会变；职业发展做不到一次发展就万事大吉；\n要抬头看市场，了解变化背后的规律，看到“技术”这条路的本质。不断调整，找到自己的阶段定位\n\n\n（2）职业发展，就是不断了解自己，发挥优势的过程\n\n职业发展没有标准答案\n认清优势，扬长避短。只要个人优势和目标匹配，推动目标的实现就很好\n\n\n（3）职业发展是自己的事\n\n要理清自己与企业的关系\n\n\n\n\n在雇佣关系中，企业提供岗位，是希望员工给客户创造的价值，给企业创造利润。企业提供的导师、培训，都是为了让员工更好地为企业服务。\n在这段“雇佣关系”中，除了薪水，“收获多或少”的主动权完全在我们手里。你可以选择“给多少钱干多少事”，这里不行换一个地方打工，也可以在项目中不断地复盘总结，提升自己的能力，为下个阶段打好基石。没有人会逼你提升，只是假以时日，前者与后者的发展会千差万别。\n\n\n（4）职业发展也不只有升职加薪\n找到自己不同人生阶段的职业目标和幸福感同样重要\n思考：当前的状态是朝着“我”期待的方向前行，还是被裹挟着？\n\n\n\n怎么拿回职业发展主动权？\n（1）追问经典问题，解决大块问题\n\n35+ 技术人都去哪里了？\n研发、测试、运维不同岗位的职业发展路径是什么？\n“大厂卷”“去国企躺平”怎么选？\n要不要转管理？\n梳理技术人职业发展的 4 个经典阶段，找到自己的位置和方向\n\n\n（2）向外看\n\n宏观：认识市场，在变化时代下，技术岗的发展趋势是什么样的？\n中观：从职场、企业角度，读懂职场的游戏规则，客观地认识职场中的事和人\n微观：认识晋升的本质，理解晋升成功的述职模型\n\n\n（3）向内看\n\n理清技术人职场要修炼的软硬技能到底有哪些？如何学习提升这些能力？\n挖掘自己的优势和潜能，重新认识自我，找到适合自己的路径\n根据自己的优劣势，构建最合适的职业发展护城河\n\n\n\n重启职业发展之路\n当下的我们，面临的是业务增速放缓甚至停滞，大厂降本增效甚至裁员，35+ 危机像空气一样蔓延……\n这正是我们自我觉醒的机会，是一次找回勇气，重新审视自己，继续向前的契机。\n这一路打怪升级，其实是在“借事修人”，提升我们的认知和能力\n\n\n\n\n\n\n\nReference\n\n\n\n\n\n\n\n\nRemark\n\nxxx需要再深入学习\n\n\n&lt;font color=red&gt;&lt;/font&gt;![]()&lt;img src=&quot;&quot; title=&quot;图片名称&quot; alt=&quot;图片无法正常加载展示！&quot; width=&quot;100%&quot; height=&quot;100%&quot; &gt;&lt;img src=&quot;&quot; width=&quot;70%&quot;&gt;&amp;emsp;****\n\n\n\n\n","tags":["职业发展"]},{"title":"深入理解：面向对象设计原则","url":"/2024/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","content":"\n\n概述\n面向对象设计的目标之一：支持可维护性复用\n（1）需要实现设计方案或源代码的重用\n（2）确保系统易于扩展和修改，具有较好的灵活性\n\n\n面向对象设计原则为支持可维护性复用而诞生\n这些原则蕴含在很多设计模式中\n是从很多设计方案中总结出的指导性原则\n这些原则也是用于评价一个设计模式的使用效果的重要指标\n\n\n\n\n\n\n\n\n\n7种常用的面向对象设计原则\n\n\n设计原则名称\n定义\n使用频率\n\n\n\n单一职责原则(Single Responsibility Principle,SRP)\n一个类只负责一个功能领域的响应职责\n★★★★☆\n\n\n开闭原则\n软件实体应该对扩展开放，面对修改关闭\n★★★★★\n\n\n里氏替换原则\n所有引用基类对象的地方能够透明的使用其子类的对象\n★★★★★\n\n\n依赖倒置原则\n抽象不应该依赖于细节，细节应该依赖于抽象\n★★★★★\n\n\n接口隔离原则\n使用多个专门的接口，而不使用单一的总接口\n★★☆☆☆\n\n\n合成复用原则\n尽量只用对象组合，而不是继承来达到复用的目的\n★★★★☆\n\n\n迪米特法则\n一个软件实体应该尽可能少地与其它实体发生相互作用\n★★★☆☆\n\n\n\n\n\n\n\n\nSingle Responsibility Principle&#x2F;SRP\n\n\n\n\n\n标题二\n\n\n\n\n\nReference\n\n\n\n\n\n\n\n\nRemark\n\nxxx需要再深入学习\n\n\n&lt;font color=red&gt;&lt;/font&gt;![]()&lt;img src=&quot;&quot; title=&quot;图片名称&quot; alt=&quot;图片无法正常加载展示！&quot; width=&quot;100%&quot; height=&quot;100%&quot; &gt;&lt;img src=&quot;&quot; width=&quot;70%&quot;&gt;****\n\n\n\n\n","categories":["OOP"],"tags":["OOP"]}]